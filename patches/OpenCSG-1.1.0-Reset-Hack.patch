diff --git a/include/opencsg.h b/include/opencsg.h
index daecacc..ffde239 100644
--- a/include/opencsg.h
+++ b/include/opencsg.h
@@ -188,6 +188,9 @@ namespace OpenCSG {
                 Algorithm = AlgorithmUnused, 
                 DepthComplexityAlgorithm = NoDepthComplexitySampling);
 
+    // call this function whenever switching the OpenGL context
+    void reset();
+
 } // namespace OpenCSG
 
 #endif // __OpenCSG__opencsg_h__
diff --git a/src/channelManager.h b/src/channelManager.h
index ecd5a1d..0e1458a 100644
--- a/src/channelManager.h
+++ b/src/channelManager.h
@@ -79,9 +79,9 @@ namespace OpenCSG {
         /// moved into alpha, to allow alpha testing of the channel.
         static void setupTexEnv(Channel channel);
 
-    private:
-
         static OpenGL::OffscreenBuffer* gOffscreenBuffer;
+
+    private:
         static int gOffscreenType;
         static bool gInUse;
 
diff --git a/src/offscreenBuffer.cpp b/src/offscreenBuffer.cpp
index e02dd83..4f978d5 100644
--- a/src/offscreenBuffer.cpp
+++ b/src/offscreenBuffer.cpp
@@ -22,19 +22,41 @@
 #include "offscreenBuffer.h"
 #include "frameBufferObject.h"
 #include "pBufferTexture.h"
+#include "channelManager.h"
+
+static bool reset_f = false;
+static bool reset_p = false;
 
 namespace OpenCSG {
 
+    void reset()
+    {
+	reset_f = true;
+	reset_p = true;
+	OpenCSG::ChannelManager::gOffscreenBuffer = NULL;
+    }
+
     namespace OpenGL {
 
         OffscreenBuffer* getOffscreenBuffer(bool fbo) {
-            static FrameBufferObject* f = new FrameBufferObject;
-            static PBufferTexture* p = new PBufferTexture;
-            
-            if (fbo)
-                return f;
-            else 
+            static FrameBufferObject* f = NULL;
+            static PBufferTexture* p = NULL;
+
+	    if (fbo) {
+	        if (reset_f || f == NULL) {
+	            delete f;
+	            f = new FrameBufferObject;
+	            reset_f = false;
+	        }
+		return f;
+	    } else {
+	        if (reset_p || p == NULL) {
+	            delete p;
+	            p = new PBufferTexture;
+	            reset_p = false;
+	        }
                 return p;
+	    }
         }
 
     } // namespace OpenGL
